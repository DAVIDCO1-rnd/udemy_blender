#!/usr/bin/python3
#+
# This script generates an Open Shading Language shader that
# produces as its output the specified mixture of cosine
# peak terms. Invoke it as follows:
#
#     osl-gen-spherical-lobes --name=«name» [--clamp-positive] «m» «n»
#
# where «name» is the name to give to the shader, «m» is the
# number of axial lobes, and «n» is the number of radial lobes.
#
# Each component will be controlled by 3 parameters: the angle at
# which to position the centre of the lobe, the intensity to give it,
# and the power to which to raise the cosine term (which controls the
# sharpness of the peak).
#
# The sum of the axial lobes is multiplied by the sum of the
# radial lobes to give the combined output.
#
# Copyright 2018 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY <http://creativecommons.org/licenses/by/4.0/>.
#-

import sys
from itertools import \
    chain
import getopt

#+
# Mainline
#-

def format_number(x) :
    return \
        "%%.%dg" % precision % x
#end format_number

opts, args = getopt.getopt \
  (
    sys.argv[1:],
    "",
    ["clamp-positive", "name=", "precision="]
  )
shader_name = None
precision = 7
clamp_positive = False
for keyword, value in opts :
    if keyword == "--clamp-positive" :
        clamp_positive = True
    elif keyword == "--name" :
        shader_name = value
    elif keyword == "--precision" :
        try :
            precision = int(value)
        except ValueError :
            precision = -1
        #end try
        if precision < 0 :
            raise getopt.GetoptError("bad --precision value")
        #end if
    #end if
#end for
if shader_name == None :
    raise getopt.GetoptError("missing --name")
#end if
if len(args) != 2 :
    raise getopt.GetoptError("need exactly two args")
#end if
m = int(args[0])
n = int(args[1])
if m < 0 or n < 0 or m + n == 0 :
    raise getopt.GetoptError("args must be non-negative and add up to 1 or more")
#end if

axial_terms = list \
  (
        "Intens_axial_%(i)d * pow((cos(theta * Freq_axial_%(i)d - Angle_axial_%(i)d * M_PI) + 1)"
        " / 2, Power_axial_%(i)d)"
    %
        {"i" : i + 1}
    for i in range(m)
  )
if len(axial_terms) > 0 :
    if len(axial_terms) > 1 :
        axial_terms = \
            (
                ["        (", "            " + axial_terms[0]]
            +
                list(chain
                  (
                    *list
                      (
                        ["        +", "            " + term]
                        for term in axial_terms[1:]
                      )
                  ))
            +
                ["        )"]
            )
    else :
        axial_terms = ["        " + axial_terms[0]]
    #end if
else :
    axial_terms = []
#end if
radial_terms = list \
  (
        "Intens_radial_%(i)d * pow((cos(phi * Freq_radial_%(i)d - Angle_radial_%(i)d * 2 * M_PI)"
        " + 1) / 2, Power_radial_%(i)d)"
    %
        {"i" : i + 1}
    for i in range(n)
  )
if len(radial_terms) > 0 :
    if len(radial_terms) > 1 :
        radial_terms = \
            (
                ["        (", "            " + radial_terms[0]]
            +
                list(chain
                  (
                    *list
                      (
                        ["        +", "            " + term]
                        for term in radial_terms[1:]
                      )
                  ))
            +
                ["        )"]
            )
    else :
        radial_terms = ["        " + radial_terms[0]]
    #end if
else :
    radial_terms = []
#end if
if len(axial_terms) == 0 :
    all_terms = radial_terms
elif len(radial_terms) == 0 :
    all_terms = axial_terms
else :
    all_terms = \
        (
            list("    " + term for term in axial_terms)
        +
            ["        *"]
        +
            list("    " + term for term in radial_terms)
        )
#end if
if clamp_positive :
    result_expr = \
        (
            "        max\n"
            "          (\n"
        +
            "\n".join
              (
                ("", "    ")[len(all_terms) > 1] + line for line in all_terms
              )
        +
            ",\n            0\n"
            "          )"
        )
else :
    result_expr = "\n".join(all_terms)
#end if

sys.stdout.write \
  (
        "shader %(name)s\n"
        "  (\n"
        "%(component_defs)s\n"
        "    normal Direction = transform(\"world\", \"object\", N),\n"
          # N is in world coords, transform back to object to allow object transform to apply
        "    output float Result = 1\n"
        "  )\n"
        "  /* generated by osl-gen-spherical-lobes. */\n"
        "  {\n"
        "    float phi = atan2(Direction[1], Direction[0]);\n"
        "    float theta = atan2(hypot(Direction[1], Direction[0]), Direction[2]);\n"
        "    Result =\n"
        "%(result)s;\n"
        "  } /*%(name)s*/\n"
    %
        {
            "name" : shader_name,
            "component_defs" : "\n".join
              (
                map
                  (
                    lambda v : "    float %s = %s" % (v[0], format_number(v[1])) + ",",
                        list
                          (
                            chain
                              (
                                *list
                                  (
                                    [
                                        ("Angle_axial_%d" % (i + 1), i / m),
                                        ("Freq_axial_%d" % (i + 1), 1),
                                        ("Intens_axial_%d" % (i + 1), 0),
                                        ("Power_axial_%d" % (i + 1), 1),
                                    ]
                                    for i in range(m)
                                  )
                              )
                          )
                    +
                        list
                          (
                            chain
                              (
                                *list
                                  (
                                    [
                                        ("Angle_radial_%d" % (i + 1), i / n),
                                        ("Freq_radial_%d" % (i + 1), 1),
                                        ("Intens_radial_%d" % (i + 1), 0),
                                        ("Power_radial_%d" % (i + 1), 1),
                                    ]
                                    for i in range(n)
                                  )
                              )
                          )
                  )
              ),
            "result" : result_expr,
        }
  )
